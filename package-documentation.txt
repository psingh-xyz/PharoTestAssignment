=== Package Documentation: Collections-Strings ====== Class: ByteString ===Superclass: StringSubclasses:(None)Instance Variables:(None)Methods:* asByteArray* asKeyCombination* asOctetString* at:  Comment: "Primitive. Answer the Character stored in the field of the receiver	indexed by the argument. Fail if the index argument is not an Integer or	is out of bounds. Essential. See Object documentation whatIsAPrimitive."* at:put:  Comment: "Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."* beginsWith:  Comment: "Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."* byteAt:* byteAt:put:* byteSize* convertFromSystemString* destroy  Comment: "destroy this string by replacing every character with a space"* findSubstring:in:startingAt:matchTable:* fuelAccept:* hasWideCharacterFrom:to:  Comment: "Only WideStrings contain these characters"* indexOfAnyOf:startingAt:  Comment: "Use double dispatching for speed"* indexOfAnyOf:startingAt:ifAbsent:  Comment: "Use double dispatching for speed"* isAsciiString* isByteString  Comment: "Answer whether the receiver is a ByteString"* isOctetString  Comment: "Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"* replaceFrom:to:with:startingAt:  Comment: "Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."* scanCharactersFrom:to:with:rightX:font:  Comment: "NB: strongly consider getting almost all these parameters from the scanner"* serializeOn:* unsignedLongAt:bigEndian:  Comment: "Return a 32bit unsigned integer quantity starting from the given byte index"* unsignedLongAt:put:bigEndian:  Comment: "Store a 32bit unsigned integer quantity starting from the given byte index"* writeBSONOn:------------------------------------------------=== Class: ByteSymbol ===Superclass: SymbolSubclasses:(None)Instance Variables:(None)Methods:* asByteArray* asKmCategoryIn:* asOctetString* at:  Comment: "Primitive. Answer the Character stored in the field of the receiver	indexed by the argument. Fail if the index argument is not an Integer or	is out of bounds. Essential. See Object documentation whatIsAPrimitive."* beginsWith:  Comment: "Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."* byteAt:* byteAt:put:  Comment: "You cannot modify the receiver."* byteSize* findSubstring:in:startingAt:matchTable:  Comment: "Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."* fuelAccept:* hasWideCharacterFrom:to:  Comment: "Always false because I only contains byte characters"* indexOfAnyOf:startingAt:  Comment: "Use double dispatching for speed"* indexOfAnyOf:startingAt:ifAbsent:  Comment: "Use double dispatching for speed"* isByteString  Comment: "Answer whether the receiver is a ByteString"* isOctetString  Comment: "Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"* privateAt:put:  Comment: "Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."* scanCharactersFrom:to:with:rightX:font:  Comment: "NB: strongly consider getting almost all these parameters from the scanner"* serializeOn:* species  Comment: "Answer the preferred class for reconstructing the receiver."* string:* writeBSONOn:------------------------------------------------=== Class: ManifestCollectionsStrings ===Superclass: PackageManifestSubclasses:(None)Instance Variables:(None)Methods:------------------------------------------------=== Class: String ===Superclass: ArrayedCollectionSubclasses:- ByteString- Symbol- WideStringInstance Variables:(None)Methods:* <  Comment: "Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."* <=  Comment: "Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."* =  Comment: "Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."* >  Comment: "Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."* >=  Comment: "Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."* addJsonDifferencesWith:to:* addToMetacelloPackages:* addToMetacelloRepositories:* addedToZnUrl:* alike:  Comment: "Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score (but see example with 7).  Case is ignored. This method is used to help find mistyped variable names in methods."* allRangesOfRegexMatches:* allRangesOfSubstring:  Comment: "('Ab cd ef Ab cd' allRangesOfSubstring: 'cd') >>> {(4 to: 5). (13 to: 14)}"* allRegexMatches:* asAlien* asAlphaNumeric:extraChars:mergeUID:  Comment: "Generates a String with unique identifier ( UID ) qualities, the difference to a	 UUID is that its beginning is derived from the receiver, so that it has a meaning	 for a human reader.	 Answers a String of totalSize, which consists of 3 parts	 1.part: the beginning of the receiver only consisting of		a-z, A-Z, 0-9 and extraChars in Collection additionallyAllowed ( which can be nil )	 2.part: a single _	 3.part: a ( random ) UID of size >= minimalSizeOfRandomPart consisting of		a-z, A-Z, 0-9	 Starting letters are capitalized. 	 TotalSize must be at least 1.	 Exactly 1 occurrence of $_ is guaranteed ( unless additionallyAllowed includes $_ ).	 The random part has even for small sizes good UID qualitites for many practical purposes.	 If only lower- or uppercase letters are demanded, simply convert the answer with	 say #asLowercase. The probability of a duplicate will rise only moderately ( see below ).	 Example: 		size of random part = 10		in n generated UIDs the chance p of having non-unique UIDs is			n = 10000 ->  p < 1e-10		if answer is reduced to lowerCase: p < 1.4 e-8			n = 100000 -> p < 1e-8		at the bottom is a snippet for your own calculations  		Note: the calculated propabilites are theoretical,			for the actually used random generator they may be much worse"* asBSONRegex* asBrick* asByteArray  Comment: "Convert to a ByteArray with the ascii values of the string."* asByteString  Comment: "Convert the receiver into a ByteString, if possible"* asCamelCase  Comment: "Convert to CamelCase, i.e, remove spaces, and convert starting lowercase to uppercase."* asCapitalizedPhrase* asClass  Comment: "returns a global class with my name"* asClassIfAbsent:  Comment: "returns a global class with my name"* asClassIfPresent:  Comment: "returns a global class with my name"* asClassInEnvironment:  Comment: "I return class named after myself from anEnvironment"* asClassInEnvironment:ifAbsent:* asClassVariable* asComment  Comment: "return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"* asDate  Comment: "Many allowed forms, see Date>>#readFrom:"* asDateAndTime  Comment: "Convert from UTC format"* asDraggableMorph* asDuration  Comment: "Convert from [-]D:HH:MM:SS[.S] format. What is between [] implies optional elements"* asEmailHeaderString* asEncodedUrl  Comment: "Send this instead of `#asUrl` if I potentially have characters not allowed by the URL spec, which Zinc enforces on input to its parser. Example: `'https://en.wikipedia.org/wiki/Česká republika' asEncodedUrl`"* asExternalTypeOn:* asFFILibrary* asFileName  Comment: "Answer a String made up from the receiver that is an acceptable file 	name."* asFileReference* asFilename  Comment: "`#asFileName` leaves in $: which mac doesn't like"* asFourCode  Comment: "'abcd' asFourCode >>> -513645724"* asFunction:* asHTMLString  Comment: "substitute the < & > into HTML compliant elements"* asHex  Comment: "'A' asHex >>> '16r41'"* asInstanceSideBehaviorName* asInteger  Comment: "Return the integer present in the receiver, or nil. In case of float, returns the integer part."* asJSONRegex* asLGitExternalString* asLowercase  Comment: "Answer a String made up from the receiver whose characters are all lowercase."* asMIMEType* asMetacelloSemanticVersionNumber* asMetacelloVersionNumber* asMongoUrl* asMorph  Comment: "Answer the receiver as a StringMorph"* asMustacheTemplate* asNumber  Comment: "Answer the Number created by interpreting the receiver as the string 	representation of a number."* asOctetString  Comment: "Convert the receiver into an octet string, if possible"* asPackage* asPackageIfAbsent:* asPath  Comment: "convert myself to a path"* asPathWith:* asPluralBasedOn:  Comment: "Append an 's' to this string based on whether aNumberOrCollection is 1 or of size 1."* asPresenter* asRegex  Comment: "Compile the receiver as a regex matcher. May raise RxParser>>syntaxErrorSignal	or RxParser>>compilationErrorSignal.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."* asRegexIgnoringCase  Comment: "Compile the receiver as a regex matcher. May raise RxParser>>syntaxErrorSignal	or RxParser>>compilationErrorSignal.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."* asResolvedBy:* asSignedInteger  Comment: "Returns the first signed integer it can find or nil."* asSlot* asSlotCollection  Comment: "Parse as slots. Use space, tab and cr as separators	Example: 	  'a b' asSlotCollection --> {a => Slot. b => Slot}	"* asString  Comment: "Answer this string."* asStringMorph  Comment: "Answer the receiver as a StringMorph"* asStringOrText  Comment: "Answer this string."* asSymbol  Comment: "Answer the unique Symbol whose characters are the characters of the 	string."* asTeaUrlPattern* asText  Comment: "Answer a Text whose string is the receiver."* asTime  Comment: "Many allowed forms, see Time>>readFrom:"* asUTF8Bytes* asUncommentedCode  Comment: "this string reprensent a commented code, let's uncomment it"* asUnsignedInteger  Comment: "Returns the first integer it can find or nil."* asUppercase  Comment: "Answer a String made up from the receiver whose characters are all uppercase."* asUrl* asValidSelector  Comment: "Returns a symbol that is a valid selector by removing any space or forbidden characters"* asVmPathName  Comment: "This method returns self encoded in the encoding the system expects.	We default to utf8 as this is the most common encoding, but we should ask the system the current encoding instead.		Also, note the method name is wrong, this should be fixed"* asWideString* asWin32WideString* asXMLEscapedString  Comment: "returns a copy of self with &, <, and > escaped with &amp;, &lt;, and &gt;"* asXMLFileHandle* asXMLHTTPRequest* asXMLStreamConverter* asXMLString  Comment: "will be deprecated; use #asXMLStringNode instead"* asXMLStringNode* asXMLURI* asZnCharacterEncoder  Comment: "Return a ZnCharacterEncoder instance using the receiver as identifier"* asZnMimeType* asZnUrl* base64Decoded  Comment: "Decode the receiver assuming it was encoded using Base64, returning a ByteArray.	Base64 encoding is a technique to represent binary data as ASCII text.	The inverse operation is ByteArray>>#base64Encoded"* beginsWith:fromList:* beginsWithEmpty:caseSensitive:  Comment: "Answer whether the receiver begins with the given prefix string. 	The comparison is case-sensitive."* bsonTypeCode* byteAt:* byteAt:put:* byteSize* capitalized  Comment: "Return a copy with the first letter capitalized"* caseInsensitiveLessOrEqual:  Comment: "Answer whether the receiver sorts before or equal to aString.	The collation order is case insensitive."* caseSensitiveLessOrEqual:  Comment: "Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."* charactersExactlyMatching:  Comment: "Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."* compare:  Comment: "Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	The collation sequence is ascii with case differences ignored.	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."* compare:caseSensitive:  Comment: "Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	"* compare:with:collated:  Comment: "'abc' = 'abc' asWideString >>> true"* contractTo:  Comment: "return myself or a copy shortened by ellipsis to smallSize"* convertFromEncoding:* convertFromWithConverter:* convertToEncoding:* convertToSystemString* convertToWithConverter:* copyReplaceAll:with:  Comment: "Answer a copy of the receiver in which all occurrences of oldSubstring have been replaced by newSubstring"* copyReplaceAll:with:asTokens:  Comment: "Answer a copy of the receiver in which all occurrences of oldSubstring have been replaced by newSubstring. ifTokens (valid for Strings only) specifies that the characters surrounding the replacement must not be alphanumeric (space). When ifTokens is set, it means that the replacement will not occur inside word."* copyReplaceTokens:with:  Comment: "Replace all occurrences of oldSubstring that are surrounded by non-alphanumeric characters"* copyWithRegex:matchesReplacedWith:* copyWithRegex:matchesTranslatedUsing:* correctAgainst:  Comment: "Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"* correctAgainst:continuedFrom:  Comment: "Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList."* correctAgainstDictionary:continuedFrom:  Comment: "Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary."* correctAgainstEnumerator:continuedFrom:  Comment: "The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."* decodeMimeHeader  Comment: "See RFC 2047, MIME Part Three: Message Header Extension for Non-ASCII  	Text. Text containing non-ASCII characters is encoded by the sequence  	=?character-set?encoding?encoded-text?=  	Encoding is Q (quoted printable) or B (Base64), handled by  	Base64MimeConverter / RFC2047MimeConverter.	Thanks to Yokokawa-san, it works in m17n package.  Try the following:	'=?ISO-2022-JP?B?U1dJS0lQT1AvGyRCPUJDKyVpJXMlQRsoQi8=?= =?ISO-2022-JP?B?GyRCJVElRiUjJSobKEIoUGF0aW8p?=' decodeMimeHeader."* decodeQuotedPrintable  Comment: "Assume receiver is in MIME 'quoted-printable' encoding, and decode it."* deepCopy  Comment: "DeepCopy would otherwise mean make a copy of the character;  since 	characters are unique, just return a shallowCopy."* destroy* displayAt:  Comment: "Display the receiver as a DisplayText at aPoint on the display screen."* displayOn:  Comment: "Display the receiver on the given DisplayMedium."* displayOn:at:  Comment: "Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."* displayOn:at:textColor:  Comment: "Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color"* displayProgressFrom:to:during:  Comment: "Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some real progress'	displayProgressFrom: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]]."* displayStringOn:* embedInXMLMarkupWriter:* encodeDoublingQuoteOn:* encodeOn:* encodeWith:  Comment: "Produce a ByteArray that encodes the receiver, using a specified encoding.	Encoding is either a ZnCharacterEncoder instance or an identifier for one."* encodedCharSetAt:  Comment: "return the character encoding in place at index; the actual EncodedCharSet, not just a number. A bad index is an Error"* encompassLine:  Comment: "Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.	Answer starts at the position following a cr (or eventually 1) and ends before a cr (or eventually at self size)	See also encompassParagraph:"* encompassParagraph:  Comment: "Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.	Answer starts at the position following a cr (or eventually 1) and ends at a cr (or eventually at self size).	See also #encompassLine:"* endOfParagraphBefore:  Comment: "Return the index of the last Character cr before position aNumber, or zero if this is the first paragraph.	'ddd' endOfParagraphBefore: 3	'dd	d' endOfParagraphBefore: 4	"* endsWith:  Comment: "Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."* endsWithAColon  Comment: "Answer whether the final character of the receiver is a colon"* endsWithDigit  Comment: "Answer whether the receiver's final character represents a digit."* excerpt:  Comment: "Answer an excerpt of the receiver that matches the first occurence of aString. If aString isn't found, nil is answered."* excerpt:radius:  Comment: "Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."* excerpt:radius:ellipsis:  Comment: "Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."* execute:against:* expandMacros  Comment: "'<t>' expandMacros >>> String tab"* expandMacrosWith:  Comment: "('Pharo is <1s>' expandMacrosWith: 'cool') >>> 'Pharo is cool'"* expandMacrosWith:with:* expandMacrosWith:with:with:* expandMacrosWith:with:with:with:* expandMacrosWithArguments:  Comment: "Interpret the receiver pattern (<1p>, <1s>, <t>...) with argument passed in anArray."* expandWithXMLNamespaceURI:  Comment: "optimized"* extractNumber* fetchRequiredForMetacelloMCVersion:* findAnySubstring:startingAt:  Comment: "Answer the index where an element of aCollection begins. If none are found, answer size + 1. aCollection is an Array of Strings or Characters."* findBetweenSubstrings:  Comment: "Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."* findCloseParenthesisFor:  Comment: "assume (self at: startIndex) is $(.  Find the matching $), allowing parentheses to nest."* findDelimiters:startingAt:  Comment: "Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1."* findIn:startingAt:matchTable:* findLastOccurrenceOfString:startingAt:  Comment: "Answer the index of the last occurrence of substring within the receiver, starting at start. If 	the receiver does not contain substring, answer 0.  Case-sensitive match used."* findSelector  Comment: "Extract a selector with keyword parts from the receiver. While this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."* findString:  Comment: "Answer the index of the first substring within the receiver. If the receiver does not contain substring, answer 0."* findString:startingAt:  Comment: "Answer the index of the first substring within the receiver, starting at start. If the receiver does not contain substring, answer 0."* findString:startingAt:caseSensitive:  Comment: "Answer the index in this String at which the substring key first occurs,	at or beyond start. The match can be case-sensitive or not. If no match	is found, zero will be returned."* findSubstring:in:startingAt:matchTable:  Comment: "Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."* findSubstringViaPrimitive:in:startingAt:matchTable:  Comment: "Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."* findTokens:  Comment: "Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."* findTokens:escapedBy:  Comment: "Answer a collection of Strings separated by the delimiters, where  	delimiters is a Character or collection of characters. Two delimiters in a  	row produce an empty string (compare this to #findTokens, which  	treats sequential delimiters as one).  	 	The characters in quoteDelimiters are treated as quote characters, such  	that any delimiter within a pair of matching quoteDelimiter characters  	is treated literally, rather than as a delimiter.  	 	The quoteDelimiter characters may be escaped within a quoted string.  	Two sequential quote characters within a quoted string are treated as  	a single character.  	 	This method is useful for parsing comma separated variable strings for  	spreadsheet import and export."* findTokens:includes:  Comment: "Divide self into pieces using delimiters.  Return the piece that includes substring anywhere in it.  Is case sensitive (say asLowercase to everything beforehand to make insensitive)."* findTokens:keep:  Comment: "Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"* findWordStart:startingAt:* format:  Comment: "Format the receiver by interpolating elements from collection, as in the following examples:"* greaseInteger  Comment: "Convert the receiver to an integer, answer nil if this is not a number."* gtDebuggerSUnitPrint* gtDisplayOn:* gtInspectorTextIn:* hasWideCharacterFrom:to:  Comment: "Return true if one of my character in the range does not fit in a single byte"* hash  Comment: "#hash is implemented, because #= is implemented"* heightToDisplayInList:* heightToDisplayInTree:* howManyMatch:  Comment: "Count the number of characters in a substring that matches up in self and aString."* includesSubstring:  Comment: "Returns whether the receiver contains the argument."* includesSubstring:caseSensitive:  Comment: "Returns whether the receiver contains the argument."* includesUnifiedCharacter* indentationIfBlank:  Comment: "Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."* indexOf:  Comment: "Return the index starting at 1 of the argument in the receiver, zero if not present."* indexOf:startingAt:  Comment: "Return the index of the argument in the receiver, only elements after the start of the element are considered zero if not present."* indexOf:startingAt:ifAbsent:* indexOfFirstUppercaseCharacter  Comment: "Returns the index of the first Uppercase character.	'uouFauhZ ' indexOfFirstUppercaseCharacter2 -> 4	New implementation much faster than older one.	"* indexOfSubCollection:  Comment: ""* indexOfSubCollection:startingAt:ifAbsent:* indexOfWideCharacterFrom:to:  Comment: "Return the index of the first wide character following anIndex"* initialIntegerOrNil  Comment: "Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"* isAllAlphaNumerics  Comment: "Returns whether the receiver is composed entirely of alphanumerics (i.e., letters or digits)."* isAllDigits  Comment: "Return whether the receiver is composed entirely of digits and has at least one digit"* isAllSeparators  Comment: "Returns whether the receiver is composed entirely of separators i.e., a space, tab, lf, cr, and newPage"* isAsciiString* isByteString  Comment: "Answer whether the receiver is a ByteString"* isLiteral* isLiteralSymbol  Comment: "Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."* isOctetString  Comment: "Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"* isPatternVariable* isString* isTypePrimitive* isValidGlobalName* isWideString  Comment: "Answer whether the receiver is a WideString"* isXMLNCName  Comment: "optimized"* isXMLNSAttributeName  Comment: "optimized"* isXMLName  Comment: "optimized"* isXMLNmtoken  Comment: "optimized"* isXMLQualifiedOrLocalName:  Comment: "returns true if self and aQualifiedOrLocalName are the	same QName or if self is a QName and aQualifiedOrLocalName	is the local part, or if they are the same NCName."* isXMLReservedAttributeName  Comment: "optimized"* isXMLWhitespace  Comment: "optimized"* javascriptOn:* join:  Comment: "Append the elements of the argument, aSequenceableCollection, separating them by the receiver."* js* jsonOn:* jsonWriteOn:* keywords  Comment: "Answer an array of the keywords that compose the receiver."* lastIndexOfPKSignature:  Comment: "Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"* lastSpacePosition  Comment: "Answer the character position of the final space or other separator character in the receiver, and 0 if none"* leadingCharRunLengthAt:* lineCorrespondingToIndex:  Comment: "Answer a string containing the line at the given character position."* lineCount  Comment: "Answer the number of lines represented by the receiver, where every line delimiter CR, LF or CRLF pair adds one line."* lineIndicesDo:  Comment: "execute aBlock with 3 arguments for each line:	- start index of line	- end index of line without line delimiter	- end index of line including line delimiter(s) CR, LF or CRLF"* lineNumber:  Comment: "Answer a string containing the characters in the given line number."* lineNumberCorrespondingToIndex:  Comment: "Answer a lineNumber for the line at the given character position."* lines  Comment: "Answer an array of lines composing this receiver without the line ending delimiters"* linesDo:  Comment: "Execute aBlock with each line in this string. The terminating line delimiters CR, LF or CRLF pairs are not included in what is passed to aBlock"* listRenderOn:atRow:bounds:color:backgroundColor:from:* loadRequiredForMetacelloMCVersion:* match:  Comment: "Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."* matches:* matchesRegex:  Comment: "Test if the receiver matches a regex.  May raise RxParser>>regexErrorSignal or	child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."* matchesRegexIgnoringCase:  Comment: "Test if the receiver matches a regex.  May raise RxParser>>regexErrorSignal or	child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."* mergeIntoMetacelloPackages:* mergeIntoMetacelloRepositories:* metacelloIntegerLessThanSelf:  Comment: "integer version components are always '>' string component"* metacelloSemanticIntegerLessThanSelf:  Comment: "integer version components are always '>' string component"* metacelloSemanticStringLessThanSelf:* metacelloSemanticVersionComponentLessThan:* metacelloStringLessThanSelf:* metacelloVersionComponentLessThan:* mustacheDo:  Comment: "as strings are collections we need to prevent it from iterating	over all of the characters. Invoke the block with self instead"* neoJsonOn:* normalizeCamelCase* nullTerminatedEncodeWith:  Comment: "Produce a ByteArray that encodes the receiver, using a specified encoding and adding a null terminator.	Encoding is either a ZnCharacterEncoder instance or an identifier for one.	Useful extension for FFI and C integration"* numArgs  Comment: "Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector. It is intended mostly for the assistance of spelling correction."* numericSuffix  Comment: "'abc98' numericSuffix >>> 98"* occursInWithEmpty:caseSensitive:  Comment: "Answer whether the receiver begins with the given prefix string. 	The comparison is case-sensitive."* onlyLetters  Comment: "answer the receiver with only letters"* packToArity:  Comment: "WARNING: Here applies the same rules as in ByteArray>>#rollToArity:, check there!"* packageFileSpecFor:* padLeftTo:* padLeftTo:with:* padRightTo:* padRightTo:with:* padded:to:with:* parseLiterals* parseXML* pluralize* prefixMatchesRegex:  Comment: "Test if the receiver's prefix matches a regex.		May raise RxParser class>>regexErrorSignal or child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."* prefixMatchesRegexIgnoringCase:  Comment: "Test if the receiver's prefix matches a regex.		May raise RxParser class>>regexErrorSignal or child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."* print:on:* printOn:  Comment: "Print inside string quotes, doubling inbedded quotes."* putOn:  Comment: "Write the receiver onto aStream by iterating over its elements.	In general we assume aStream accepts the receiver's elements as element type.	This is an optimisation.	Return self."* qualifyWithXMLPrefix:  Comment: "optimized"* recordRequiredForMetacelloMCVersion:* regex:matchesCollect:* regex:matchesDo:* removeFromMetacelloPackages:* removeFromMetacelloRepositories:* renderOn:* repeat:  Comment: "returns a new string concatenated by itself repeated n times		'abc' repeat: 3. 'abcabcabc'	"* replaceFrom:to:with:startingAt:  Comment: "Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."* resolvePackageSpecsNamedForMetacelloMCVersion:visited:ifAbsent:* romanNumber* sameAs:  Comment: "Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."* search:  Comment: "compatibility method to make regexp and strings work polymorphicly"* seasideMimeDocument* seasideMimeDocumentType:* seasideMimeType* seasideUrl* setAuthorInMetacelloConfig:* setAuthorInMetacelloVersion:* setBlessingInMetacelloConfig:* setBlessingInMetacelloVersion:* setDescriptionInMetacelloConfig:* setDescriptionInMetacelloVersion:* setImportInVersionSpec:* setIncludesInMetacelloPackage:* setLoadsInMetacelloProject:* setPackage:withInMetacelloConfig:* setPostLoadDoItInMetacelloSpec:* setPreLoadDoItInMetacelloSpec:* setProject:withInMetacelloConfig:* setRequiresInMetacelloPackage:* setTimestampInMetacelloConfig:* setTimestampInMetacelloVersion:* skipAnySubstring:startingAt:  Comment: "Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."* skipDelimiters:startingAt:  Comment: "Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."* squeezeOutNumber  Comment: "Try to find a number somewhere in this string, as explained in Number>readFrom:		this method returns the first number found"* startingAt:match:startingAt:  Comment: "Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."* startsWithDigit  Comment: "Answer whether the receiver's first character represents a digit"* stemAndNumericSuffix  Comment: "Parse the receiver into a string-valued stem and a numeric-valued suffix."* stonContainSubObjects* stonOn:* storeOn:  Comment: "Print inside string quotes, doubling inbedded quotes."* string* stringhash* substrings  Comment: "Answer an array of non-empty substrings from the receiver separated by	one or more whitespace characters."* substrings:  Comment: "Answer an array of non-empty substrings from the receiver separated by	one or more characters from the 'separators' argument collection."* surroundedBy:  Comment: "Answer the receiver with leading and trailing aString."* surroundedByDoubleQuotes* surroundedBySingleQuotes  Comment: "Answer the receiver with leading and trailing quotes."* threeWayCompareTo:  Comment: "Do a three-way comparison between the receiver and anotherObject, returning	-1 if self < anotherObject	0 if self = anotherObject	1 if self > anotherObject	This assumes a total order in accordance with the mathematical law of trichotomy.	See also:  http://en.wikipedia.org/wiki/Three-way_comparison"* translateFrom:to:table:  Comment: "translate the characters in the string by the given table, in place"* translateToLowercase  Comment: "Translate all characters to lowercase, in place"* translateToUppercase  Comment: "Translate all characters to lowercase, in place"* translateWith:  Comment: "translate the characters in the string by the given table, in place"* translated  Comment: "answer the receiver translated to the default language"* translatedTo:  Comment: "answer the receiver translated to the given locale id"* treeRenderOn:bounds:color:font:from:* trim  Comment: "Trim separators from both sides of the receiving string."* trimBoth  Comment: "Trim separators from both sides of the receiving string."* trimBoth:  Comment: "Trim characters satisfying the condition given in aBlock from both sides of the receiving string."* trimLeft  Comment: "Trim separators from the left side of the receiving string."* trimLeft:  Comment: "Trim characters satisfying the condition given in aBlock from the left side of the receiving string."* trimLeft:right:  Comment: "Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string."* trimLineSpaces  Comment: "Trim the spaces from the right side of each line. Useful for code"* trimRight  Comment: "Trim separators from the right side of the receiving string."* trimRight:  Comment: "Trim characters satisfying the condition given in aBlock from the right side of the receiving string."* trimmed* truncate  Comment: "Truncate the receiver to 30 characters."* truncate:  Comment: "Truncate the receiver to anInteger characters."* truncate:ellipsis:  Comment: "Truncate the receiver to anInteger characters and append aString as ellipsis if necessary."* truncateTo:  Comment: "return myself or a copy shortened to smallSize."* truncateWithElipsisTo:  Comment: "Return myself or a copy suitably shortened but with elipsis added"* typeTable* uncapitalized  Comment: "Return a copy with the first letter downShifted (in lower case)"* unzipped* urlDecoded  Comment: "URL Decode the receiver and return the resulting String.	This is an encoding where characters that are illegal in a URL are escaped."* urlEncoded  Comment: "URL Encode the receiver and return the resulting String.	This is an encoding where characters that are illegal in a URL are escaped."* utf8Encoded  Comment: "Produce a ByteArray encoding the receiver using UTF-8,	the recommended encoding for Strings, unless you know what you are doing."* widthToDisplayInList:* widthToDisplayInTree:* withBlanksCondensed  Comment: "Return a copy of the receiver with leading/trailing blanks (separators) removed	 and consecutive white spaces (separators) condensed to the first one."* withCRs  Comment: "Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns. For example '-hello\-hi' will be	'-hello	 -hi'"* withInternalLineEndings  Comment: "Answer a new instance where all occurrences of CRLF and LF are substituted with CR. Pharo internally uses CR for carriage return."* withInternetLineEndings  Comment: "change line endings from CR's and LF's to CRLF's.  This is probably in prepration for sending a string over the Internet"* withLineEndings:  Comment: "Answer a new instance where all occurrences of CRLF, CR, and LF are substituted with the specified line ending string."* withNoLineLongerThan:  Comment: "Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"* withSeparatorsCompacted  Comment: "Returns a copy of the receiver with each sequence of whitespace (separator)     characters replaced by a single space character"* withSqueakLineEndings  Comment: "Answer a new instance where all occurrences of CRLF and LF are substituted with CR."* withUnixLineEndings  Comment: "Answer a new instance where all occurrences of CRLF and LF are substituted with LF."* withoutLeadingDigits  Comment: "Answer the portion of the receiver that follows any leading series of digits and separators.	If the receiver consists entirely of digits and separators, return an empty string"* withoutPeriodSuffix  Comment: "Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "* withoutPrefix:  Comment: "Remove the given prefix, if present."* withoutQuoting  Comment: "remove the initial and final quote marks (single quote for string, or double quotes for comments), if present (and if matches nesting quotes). Have a look at testWithoutQuoting. If you want to remove single/double quotes not in first and last positions of the strings, have a look at copyWithout: $' "* withoutSuffix:  Comment: "Remove the given suffix, if present."* withoutTrailingDigits  Comment: "Answer the portion of the receiver that precedes any leading series of digits and separators.	If the receiver consists entirely of digits and separators, return an empty string"* withoutTrailingNewlines  Comment: "Return a copy of the receiver with any combination of cr/lf characters at the end removed"* wordBefore:  Comment: "('word before index' wordBefore: 4) >>> 'word'"* writeLeadingCharRunsOn:* xmlCopyWithoutWhitespace* xmlLocalNameAfterPrefix* xmlLocalNameAfterPrefix:  Comment: "optimized"* xmlPrefixBeforeLocalName  Comment: "optimized"* xmlPrefixBeforeLocalName:  Comment: "optimized"* xmlWriterLocalNameAfterPrefix:  Comment: "optimized"* xmlWriterPrefixBeforeLocalName  Comment: "optimized"* zipped------------------------------------------------=== Class: Symbol ===Superclass: StringSubclasses:- ByteSymbol- WideSymbolInstance Variables:(None)Methods:* ,  Comment: "Concatenate the receiver with otherSymbolOrString and return the result.	Overwritten to always return Symbol results,	whether the argument is a Symbol or a String"* =  Comment: "Compare the receiver and aSymbol."* =>  Comment: "If the slot we give as argument is not present in the image, we will get a nil. In that case we should throw an explicit error to the user saying a slot is missing."* argumentCount* asAccessor* asAnnouncement* asClassVariable* asGlamourOriginIdentifier* asGlamourTargetIdentifier* asIcon* asMetacelloAttributeList* asMetacelloAttributePath* asMethodPreamble* asMutator  Comment: "Return a setter message from a getter message.	Return self if it is already a setter. 	Pay attention the implementation should be improved to return valid selector."* asOneArgSelector* asSlot* asSortFunction  Comment: "Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in ascending order using the <=> method."* asString  Comment: "Refer to the comment in String|asString."* asSymbol  Comment: "Refer to the comment in String|asSymbol."* asTestSelector  Comment: "Converts a method selector into a test selector in form of #testOriginalSelector"* ascending  Comment: "Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in ascending order using the <=> method."* at:put:  Comment: "You cannot modify the receiver."* brickValue:* brickValue:withEnoughArguments:* bsonTypeCode* capitalized* collatedBy:  Comment: "Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated iusing aSortFunction."* copy  Comment: "Answer with the receiver, because Symbols are unique."* cull:* cull:cull:* descending  Comment: "Return a SortFunction around the receiver, where the receiver will be used as a unary message to send to both a and b during sorting, and then the result of said send will be collated in descending order using the <=> method."* errorNoModification* fixTemps* flushCache  Comment: "Tell the virtual machine to remove all entries with this symbol as a selector from its method lookup caches, if it has any.  This 	must be done whenever a method is added, redefined or removed, so that message lookups reflect the revised organization.  c.f. 	Behavior>>flushCache & CompiledMethod>>flushCache.  Essential. See MethodDictionary class comment."* glamourValueWithArgs:* gtInspectorImplementorsIn:* gtInspectorSendersIn:* handlesAnnouncement:  Comment: "Anything else than the announcement identifier (in the case of symbol i.e. #foo for ... on: #foo send: #bar to: nil) will not 	be handled."* implementors* includesKey:* isBinary  Comment: "Answer whether the receiver is a binary message selector."* isDoIt* isInfix  Comment: "Answer whether the receiver is an infix message selector."* isKeyword  Comment: "Answer whether the receiver is a message keyword."* isOrientedFill  Comment: "Needs to be implemented here because symbols can occupy 'color' slots of morphs."* isPseudovariableName  Comment: "Answer true if I am a pseudo-variable name.	#self isPseudovariableName -> true	"* isSelectorSymbol* isSymbol* isUnary  Comment: "Answer whether the receiver is an unary message selector."* mdlCull:cull:* numArgs:  Comment: "Answer a string that can be used as a selector with n arguments.	 TODO: need to be extended to support shrinking and for selectors like #+ "* optionFor:ifPresent:* phlowValue:* phlowValue:value:* phlowValue:withEnoughArguments:* precedence  Comment: "Answer the receiver's precedence, assuming it is a valid Smalltalk	message selector or 0 otherwise.  The numbers are 1 for unary,	2 for binary and 3 for keyword selectors."* prepareForDelivery  Comment: "somehow symbol can be announcemnt"* replaceFrom:to:with:startingAt:* senders* separateKeywords  Comment: "#'foo:zork:' separateKeywords -> 'foo:  zork:'"* setForDo:withInMetacelloConfig:* setForVersion:withInMetacelloConfig:* setPostLoadDoItInMetacelloSpec:* setPreLoadDoItInMetacelloSpec:* shallowCopy  Comment: "Answer with the receiver, because Symbols are unique."* sorted:  Comment: "Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then <= is used for comparison. We convert the symbol to an array because symbols can't be changed."* stonOn:* storeOn:* string:* uncapitalized  Comment: "Answer an object like the receiver but with first character downshifted if necessary"* value:* veryDeepCopyWith:  Comment: "Return self.  I am immutable in the Morphic world.  Do not record me."------------------------------------------------=== Class: WideString ===Superclass: StringSubclasses:(None)Instance Variables:(None)Methods:* asFourCode* asLowercase  Comment: "Answer a copy of self with all characters in a lower case.	This might be a difficult task, ask Unicode."* asUppercase  Comment: "Answer a copy of self with all characters in an upper case.	This might be a difficult task, ask Unicode."* asWideString* at:  Comment: "Answer the Character stored in the field of the receiver indexed by the	 argument.  Primitive.  Fail if the index argument is not an Integer or is out	 of bounds.  Essential.  See Object documentation whatIsAPrimitive."* at:put:  Comment: "Store the Character into the field of the receiver indicated by the index.	 Primitive.  Fail if the index is not an Integer or is out of bounds, or if the	 argument is not a Character.  Essential.  See Object documentation whatIsAPrimitive."* byteAt:* byteAt:put:* byteSize* copyFrom:to:* findIn:startingAt:matchTable:* includesUnifiedCharacter* isUnicodeStringWithCJK* isWideString  Comment: "Answer whether the receiver is a WideString"* mutateJISX0208StringToUnicode* replaceFrom:to:with:startingAt:* scanCharactersFrom:to:with:rightX:font:  Comment: "NB: strongly consider getting almost all these parameters from the scanner"* wordAt:* wordAt:put:* writeBSONOn:------------------------------------------------=== Class: WideSymbol ===Superclass: SymbolSubclasses:(None)Instance Variables:(None)Methods:* asWideString* at:  Comment: "Answer the Character stored in the field of the receiver indexed by the argument."* byteAt:* byteAt:put:* byteSize* findIn:startingAt:matchTable:* isWideString  Comment: "Answer whether the receiver is a WideString"* mutateJISX0208StringToUnicode* privateAt:put:  Comment: "Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."* scanCharactersFrom:to:with:rightX:font:  Comment: "NB: strongly consider getting almost all these parameters from the scanner"* species  Comment: "Answer the preferred class for reconstructing the receiver."* string:* wordAt:* wordAt:put:------------------------------------------------